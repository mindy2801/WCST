print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
maxsubj <- 39
up for sd_parameters
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 100
maxsubj <- 39
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
twoLLstack
cursubj
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 100
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
group for sd_parameters
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 3
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 50
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
parstack
parstack[,,5]
r_par <- parstack[,,5]
sd_par <- rbind(control=apply(r_par[1:49,],2,sd), sdi=apply(r_par[50:88,],2,sd))
sd_par
mean_par <- rbind(control=colMeans(r_par[1:49,]), sdi=colMeans(r_par[50:88,]))
median_par <- rbind(control=apply(r_par[1:49,],2,median), sdi=apply(r_par[50:88,],2,median))
mean_par
median_par
save.image("C:/Users/desk1/Desktop/WCST-master/sdi_sd.RData")
load("Code17b_choice_s1-88_iter100.Rdata")
head(rawdatamat)
table(rawdatamat$V258)
#SDI 1:39, control 40:88
##Table.3
dat_sdi <- parstack[1:39,1:3,5]
dat_control <- parstack[40:88,1:3,5]
mean_s <- apply(dat_sdi,2,mean)
mean_c <- apply(dat_control,2,mean)
median_s <- apply(dat_sdi,2,median)
median_c <- apply(dat_control,2, median)
sd_s <- apply(dat_sdi, 2, sd)
sd_c <- apply(dat_control, 2, sd)
t3 <- rbind(mean_c,mean_s,median_c,median_s,sd_c,sd_s)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Original Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
library(knitr)
library(kableExtra)
trol 40:88
##Table.3
dat_sdi <- parstack[1:39,1:3,5]
dat_control <- parstack[40:88,1:3,5]
mean_s <- apply(dat_sdi,2,mean)
mean_c <- apply(dat_control,2,mean)
median_s <- apply(dat_sdi,2,median)
median_c <- apply(dat_control,2, median)
sd_s <- apply(dat_sdi, 2, sd)
sd_c <- apply(dat_control, 2, sd)
t3 <- rbind(mean_c,mean_s,median_c,median_s,sd_c,sd_s)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Original Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
#only for rpd1
rm(list=ls())
source("rpd1_function.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 50
maxsubj <- nrow(rawdatamat)
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,1,1,5)  #boundaries for r, p, d
lb=parbounds[1:3]
ub=parbounds[4:6]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*1)),dim=c(maxsubj,maxiter,1)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*1)),dim=c(maxsubj,maxiter,1))
parstack <- array(NA, c(maxsubj, 3, 1)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,1))
finalBICstack <- array(NA, dim=c(maxsubj,1,1))
##For hypothesized models
for (cursubj in 1:maxsubj){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
temppars <- runif(3)*ub
setmod <- optim(temppars, vattG2overarchfun, tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(3)*ub
tempmod <- optim(temppars, vattG2overarchfun, tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,1] <- tempmod$value
BICstack[cursubj,curiter,1] <- tempmod$value+3*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter,"  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1], "  p=",roundpars[2],"  d=",roundpars[3])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,1] <- contractpars(setmod$par)
finalLLstack[cursubj,,1] <- setmod$value
finalBICstack[cursubj,,1] <- tempmod$value+3*log(curlength-1)
} #subject loop
catt33G2 <- array(NA, c(maxsubj, 1, 1))
catt33BIC <- array(NA, c(maxsubj, 1, 1))
for(cursubj in 1:88){
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
catt33G2[cursubj,1,1] <- cattG2fun(rep(1/3,3),curchoices)
catt33BIC[cursubj,1,1] <-catt33G2[cursubj,1,1]+3*log(curlength-1)
}
##
mean_par <- rbind(control=colMeans(parstack[1:49,,]), sdi=colMeans(parstack[50:88,,]))
median_par <- rbind(control=apply(parstack[1:49,,],2,median), sdi=apply(parstack[50:88,,],2,median))
sd_par <- rbind(control=apply(parstack[1:49,,],2,sd), sdi=apply(parstack[50:88,,],2,sd))
BIC_rpd1 <- mean(finalBICstack)
LL_base <- mean(catt33G2)
BIC_base <- mean(catt33BIC)
sd_par
rawdatamat[1:2,]
table(rawdatamat$V258)
mean_par
save.image("C:/Users/CCSLAB1/Desktop/WCST/constrained.RData")
load("constrained.Rdata")
##Table.3
dat_control <- parstack[1:49,1:3]
rm(list=ls())
---
title: "Simulation Output"
output: html_document
---
##Mean parameters: original code
```{r echo=FALSE}
rm(list=ls())
library(knitr)
library(kableExtra)
load("Code17b_choice_s1-88_iter100.Rdata")
#SDI 1:39, control 40:88
##Table.3
dat_sdi <- parstack[1:39,1:3,5]
dat_control <- parstack[40:88,1:3,5]
mean_s <- apply(dat_sdi,2,mean)
mean_c <- apply(dat_control,2,mean)
median_s <- apply(dat_sdi,2,median)
median_c <- apply(dat_control,2, median)
sd_s <- apply(dat_sdi, 2, sd)
sd_c <- apply(dat_control, 2, sd)
t3 <- rbind(mean_c,mean_s,median_c,median_s,sd_c,sd_s)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Original Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
```
##Mean parameters: DY code
```{r echo=FALSE}
load("DY_MLE.Rdata")
#Control 1:49, SDI 50:88
##Table.3
dat_control <- parstack[1:49,1:3,5]
dat_sdi <- parstack[50:88,1:3,5]
mean_s <- apply(dat_sdi,2,mean)
mean_c <- apply(dat_control,2,mean)
median_s <- apply(dat_sdi,2,median)
median_c <- apply(dat_control,2, median)
sd_s <- apply(dat_sdi, 2, sd)
sd_c <- apply(dat_control, 2, sd)
t3 <- rbind(mean_c,mean_s,median_c,median_s,sd_c,sd_s)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "DY Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
```
##Mean parameters: deleting i
```{r echo=FALSE}
load("constrained.Rdata")
##Table.3
t3 <- rbind(mean_par, median_par, sd_par)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Constrained Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
```
##BIC comparisons
```{r echo=FALSE}
#Average BIC
orgin_BIC <- mean(BICfinalmat[,5])
DY_BIC <- mean(r_BIC)
contrained_BIC <- mean(BIC_rpd1)
```
load("constrained.Rdata")
load("constrained.RData")
##Table.3
t3 <- rbind(mean_par, median_par, sd_par)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Constrained Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
t3
##Table.3
t3 <- rbind(mean_par, median_par, sd_par)
t3
mean_par
as.data.frame(t3)
t3 <- as.data.frame(t3)
kable(t3, format = "html", caption = "Constrained Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
t3
##Table.3
t3 <- rbind(mean_par, median_par, sd_par)
t3 <- as.data.frame(t3)
kable(t3)
t3
