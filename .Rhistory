full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
T_DY
dat_control <- parstack[1:49,1:3,5]
dat_sdi <- parstack[50:88,1:3,5]
mean_s <- apply(dat_sdi,2,mean)
mean_c <- apply(dat_control,2,mean)
median_s <- apply(dat_sdi,2,median)
median_c <- apply(dat_control,2, median)
sd_s <- apply(dat_sdi, 2, sd)
sd_c <- apply(dat_control, 2, sd)
t3 <- rbind(mean_c,mean_s,median_c,median_s,sd_c,sd_s)
t3 <- as.data.frame(t3)
T_DY<- kable(t3, format = "html", caption = "DY Code", align="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
add_header_above(c("Group"=1, "Parameters" = 3)) %>%
group_rows("Mean", 1,2) %>%
group_rows("Median", 3,4) %>%
group_rows("Standard deviation", 5,6)
T_org
T_DY
#Average BIC
meanBIC <- colMeans(BICfinalmat)
meanBIC <- meanBIC[!is.na(meanBIC)]
#Create table tags
names <- expand.grid(i=c("i","0","1"),d=c("d",""),p=c("p",""))
names <- as.matrix(names)
for(i in 2:3){
loc <- names[,i]==""
names[loc,i] <- "fixed"
names[!loc,i] <- "free"
}
loc <- names[,1]=="i"
names[loc,1] <- "fixed"
#Create table
t <- data.frame(meanBIC, names)
t2 <- as.data.frame(matrix(t[,1], ncol=3, byrow=T))
t2[,4] <- NA; t2[1,4] <- mean(catt33G2) #deckbaseBIC is strange
colnames(t2)<-c("f free", "f = 0", "f = 1", "Baseline model")
row_t2 <- data.frame(v1=c(rep("p free", 2),rep("p = r", 2)),v2=c(rep(c("d free", "d = 1"),2)),t2)
kable(row_t2, format="html", col.names=c("","",colnames(t2)), caption="Table 2", algin="l") %>%
kable_styling(bootstrap_options = "striped",
full_width = F) %>%
collapse_rows(columns=1:2) %>%
add_header_above(c("Model constraints"=6))
load("Code17b_choice_s1-88_iter100.Rdata")
BICfinalmat
#Average BIC
meanBIC <- colMeans(BICfinalmat)
meanBIC
BICfinalmat
#Average BIC
meanBIC <- colMeans(BICfinalmat[,5])
#Average BIC
meanBIC <- mean(BICfinalmat[,5])
meanBIc
meanBIC
load("DY_MLE.Rdata")
BIC_base
BIC_5
r_BIC
mean(r_BIC)
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
rawdatamat
table(rawdatamat$V258)
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 5
maxsubj <- 50 #nrow(rawdatamat)
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:maxsubj){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 100
maxsubj <- 50 #nrow(rawdatamat)
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:maxsubj){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
maxsubj
maxsubj <- nrow(rawdatamat)
for (cursubj in 50:maxsubj){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
maxsubj <- 39
up for sd_parameters
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 100
maxsubj <- 39
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
twoLLstack
cursubj
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 100
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
group for sd_parameters
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 3
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
rm(list=ls())
source("probability.R")
#Set data
datname="managed sample data.txt"
rawdatamat=read.table(datname,encoding="UTF-8")
subjlabels=rawdatamat[,257]				#reads extra information in datafile if available
subjgroup= rawdatamat[,258]
#Set simulation conditions
maxiter <- 50
maxsubj <- 88
lengthvec <- 128-rowSums(rawdatamat[,1:128]==0)
modelstorun <- 5
parbounds <- c(0,0,.01,.01,1,1,5,5)  #boundaries for r, p, d, i
lb=parbounds[1:4]
ub=parbounds[5:8]
stretchpars=function(opars) -log((ub-lb)/(opars-lb)-1)	#opars=original pars
contractpars=function(spars) (ub-lb)/(exp(-spars)+1)+lb		#spars=stretched pars
#Generate Model Names
freeparsmat <- expand.grid(r=c("r",""),i=c("i","0","1"),d=c("d",""),p=c("p",""))
freeparsmat <- as.matrix(freeparsmat)
freeparsmat <- freeparsmat[,c(1,4,3,2)] #Needed to match the sequence as the original one.
fixedvalsmat <- expand.grid(r=c(-1,1),i=c(-1,0.0001,1-1e-8),d=c(-1,1),p=c(-1,1)) # -1 means free parameter
fixedvalsmat <- as.matrix(fixedvalsmat)
fixedvalsmat <- fixedvalsmat[,c(1,4,3,2)]
pequalsrmat <- fixedvalsmat[,"p"]
pequalsrmat[pequalsrmat==-1] <- 0
modnames <- apply(freeparsmat, 1, paste, collapse="")
#Initailize stacks
twoLLstack <- array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24)) #row is subj, col is LL, dim is number of models
BICstack=array(rep(NA,(maxsubj*maxiter*24)),dim=c(maxsubj,maxiter,24))
parstack <- array(NA, c(maxsubj, 4, 24)) #col is parameters
finalLLstack <- array(NA, dim=c(maxsubj,1,24))
finalBICstack <- array(NA, dim=c(maxsubj,1,24))
##For hypothesized models
#Run simulations
for (cursubj in 50:88){ #for 88 subjects
curlength=lengthvec[cursubj]
curchoices=data.frame(rawdatamat[cursubj,1:curlength])
curreinf=data.frame(rawdatamat[cursubj,129:(128+curlength)])
for (curmod in modelstorun){  #for 24 models
temppars <- runif(4)*ub
setmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
for (curiter in 1:maxiter){ #run 100 iterations. Optimize the -LL from MLE model
temppars <- runif(4)*ub
tempmod <- optim(temppars, vattG2overarchfun, freeletters=freeparsmat[curmod,],fixedvals=fixedvalsmat[curmod,],
pequalsr=pequalsrmat[curmod],tempchoices=curchoices,tempreinf=curreinf,predpfun=vattpredpfun9,
method="Nelder-Mead") #abnormal termination happens with L-BFGS-B. have to manually re-range parameters
twoLLstack[cursubj,curiter,curmod] <- tempmod$value
BICstack[cursubj,curiter,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
if (tempmod$value < setmod$value){ #Stack parameters
setmod <- tempmod}
roundpars <- round(contractpars(tempmod$par),3)
print(noquote(c("subj#=",cursubj," iter=",curiter," model=",modnames[curmod], "  -2LL=",round(tempmod$value,3) )))
print(noquote(c("r=",roundpars[1],"  p=",roundpars[2],"  d=",roundpars[3],"   i=",roundpars[4])))
print(noquote(""))
flush.console()
} #iteration loop
#Calculate information criteria
parstack[cursubj,,curmod] <- contractpars(setmod$par)
finalLLstack[cursubj,,curmod] <- setmod$value
finalBICstack[cursubj,,curmod] <- tempmod$value+sum(freeparsmat[curmod,]!="")*log(curlength-1)
} #model loop
} #subject loop
parstack
parstack[,,5]
r_par <- parstack[,,5]
sd_par <- rbind(control=apply(r_par[1:49,],2,sd), sdi=apply(r_par[50:88,],2,sd))
sd_par
mean_par <- rbind(control=colMeans(r_par[1:49,]), sdi=colMeans(r_par[50:88,]))
median_par <- rbind(control=apply(r_par[1:49,],2,median), sdi=apply(r_par[50:88,],2,median))
mean_par
median_par
save.image("C:/Users/desk1/Desktop/WCST-master/sdi_sd.RData")
